# [BOJ] 11652 카드

## 문제 전략

1. **정렬을 이용한 그룹화**: 카드를 오름차순으로 정렬하면 같은 숫자의 카드들이 인접하게 배치됩니다. 이를 통해 한 번의 순회로 각 숫자의 개수를 쉽게 파악할 수 있습니다.
2. **선형 탐색 (One-pass)**: 정렬된 리스트를 인덱스 1부터 끝까지 한 번만 순회하며 연속된 숫자의 개수를 셉니다. ($O(N)$)
3. **최빈값 갱신 조건**: `current_cnt > max_cnt` 조건을 사용하여, 빈도수가 동일한 경우에는 정렬 순서상 먼저 나온(더 작은) 숫자가 유지되도록 합니다.

## 해결 과정

1. `number` 변수에 전체 카드 개수를 입력받고, `cards` 리스트에 모든 숫자를 저장합니다.
2. `cards.sort()`를 통해 리스트를 오름차순으로 정렬합니다.
3. `max_val` (최빈값), `max_cnt` (최대 빈도), `current_cnt` (현재 숫자의 빈도)를 초기값으로 설정합니다. (첫 번째 카드 기준)
4. 반복문을 통해 이전 카드와 현재 카드를 비교합니다:
   - 카드가 같다면 `current_cnt`를 1 증가시킵니다.
   - 카드가 다르다면 `current_cnt`를 1로 초기화합니다.
5. 매 단계마다 `current_cnt`가 `max_cnt`를 초과하면 `max_val`과 `max_cnt`를 현재 정보로 갱신합니다.
6. 전체 순회가 끝나면 저장된 `max_val`을 출력합니다.


## 복잡도 분석

### 시간 복잡도: $O(N \log N)$
- **입력받기**: $N$개의 카드를 입력받는 데 $O(N)$이 소요됩니다.
- **정렬**: `cards.sort()` (Timsort 알고리즘)를 사용하여 리스트를 정렬하는 데 $O(N \log N)$이 소요됩니다.
- **순회 및 빈도 계산**: 리스트를 한 번 순회하며 최빈값을 찾는 과정은 $O(N)$입니다.
- **결론**: 가장 큰 비중을 차지하는 정렬 과정에 의해 전체 시간 복잡도는 **$O(N \log N)$**이 됩니다.



## 어려웠던점

- **이 문제에서 어려웠던 부분은 없습니다**