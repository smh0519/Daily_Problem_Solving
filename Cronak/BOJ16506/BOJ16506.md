# 백준 16506번 - CPU 문제 풀이 설명

## 문제 요약
CPU 명령어를 기계어(이진수)로 변환하는 어셈블러를 만드는 문제입니다.

## 기계어 형식 (총 16비트)

```
| opcode | 0 | rD  | rA  | rB/C |
|   5비트 | 1 | 3비트| 3비트| 4비트 |
```

### 각 필드 설명

1. **opcode (5비트)**
   - 처음 4비트: 명령어 종류 (ADD=0000, SUB=0001 등)
   - 마지막 1비트: 0 = 레지스터 사용, 1 = 상수 사용
   - 예: "ADDC"이면 0000**1**, "ADD"이면 0000**0**

2. **미사용 비트 (1비트)**
   - 항상 0

3. **rD (3비트)**
   - 목적지 레지스터 번호 (0~7을 3비트로 표현)
   - 예: 5 → 101

4. **rA (3비트)**
   - 첫 번째 피연산자 레지스터 번호

5. **rB 또는 C (4비트)** ⭐ 중요!
   - 명령어에 'C'가 **없으면**: rB (레지스터 번호 0~7을 **3비트로 표현 + 마지막 비트 0**)
     - 예: rB=7 → 1110 (111 + 0)
   - 명령어에 'C'가 **있으면**: C (상수 0~15를 **4비트로 표현**)
     - 예: C=7 → 0111

## 사용한 풀이 기법

### 1. map을 이용한 명령어-이진수 매핑
```cpp
map<string, string> opcodeMap;
opcodeMap["ADD"] = "0000";
opcodeMap["SUB"] = "0001";
// ... 등등
```
- 14개의 명령어를 각각 4비트 이진수로 미리 저장
- 입력받은 명령어 문자열로 즉시 이진수를 찾을 수 있음
- O(log N) 시간에 검색 가능

### 2. string의 back()과 pop_back()으로 'C' 판별
```cpp
if (opcode.back() == 'C') {
    opcode.pop_back();  // 'C' 제거
    result += opcodeMap[opcode] + "1";
} else {
    result += opcodeMap[opcode] + "0";
}
```
- `back()`: 문자열 마지막 문자 확인
- `pop_back()`: 문자열 마지막 문자 제거
- "ADDC" → "ADD"로 변환하여 map에서 검색

### 3. 십진수를 이진수로 변환 (2의 거듭제곱 분해)
```cpp
int temp = rD;
string rD_binary = "";

if (temp >= 4) {     // 2^2 = 4
    rD_binary += "1";
    temp -= 4;
} else {
    rD_binary += "0";
}

if (temp >= 2) {     // 2^1 = 2
    rD_binary += "1";
    temp -= 2;
} else {
    rD_binary += "0";
}

if (temp >= 1) {     // 2^0 = 1
    rD_binary += "1";
} else {
    rD_binary += "0";
}
```
- 큰 자릿수부터 차례로 확인 (4 → 2 → 1)
- 각 자릿수보다 크거나 같으면 "1", 아니면 "0"
- 3비트 변환: 4, 2, 1 확인
- 4비트 변환 (상수 C): 8, 4, 2, 1 확인
- 4비트 변환 (레지스터 rB): 4, 2, 1 확인 + 마지막에 "0" 추가

### 4. 'C' 유무에 따른 마지막 4비트 처리
```cpp
// 'C'가 있는 경우: 상수를 4비트로 (8, 4, 2, 1)
if (opcode.back() == 'C' || result[4] == '1') {
    // 8, 4, 2, 1 순서로 변환
    // ...
}
// 'C'가 없는 경우: 레지스터를 3비트로 + 마지막 0 추가
else {
    // 4, 2, 1 순서로 변환
    // ...
    rB_binary += "0";  // 마지막 비트는 항상 0
}
```
- 'C'가 있으면: 0~15를 4비트로 완전히 표현
- 'C'가 없으면: 0~7을 3비트로 표현하고 마지막 비트는 0으로 고정

### 5. 문자열 연결(+=)로 최종 결과 조립
```cpp
string result = "";
result += opcodeMap[opcode];  // 4비트
result += "1" 또는 "0";        // 1비트
result += "0";                 // 1비트
result += rD_binary;           // 3비트
result += rA_binary;           // 3비트
result += rB_binary;           // 4비트
```
- 순서대로 이어붙여 16비트 완성

## 입출력 예제 분석

### 입력
```
1
ADDC 3 2 7
```

### 처리 과정

1. **opcode 처리**
   - "ADDC" → 끝이 'C' → "ADD" + "1"
   - "ADD"는 0000 → **00001** (5비트)

2. **미사용 비트**
   - **0** (1비트)

3. **rD = 3**
   - 3 ≥ 4? NO → "0"
   - 3 ≥ 2? YES → "1", 남은 값: 1
   - 1 ≥ 1? YES → "1"
   - 결과: **011** (3비트)

4. **rA = 2**
   - 2 ≥ 4? NO → "0"
   - 2 ≥ 2? YES → "1", 남은 값: 0
   - 0 ≥ 1? NO → "0"
   - 결과: **010** (3비트)

5. **C = 7** ('C'가 있으므로 상수)
   - 7 ≥ 8? NO → "0"
   - 7 ≥ 4? YES → "1", 남은 값: 3
   - 3 ≥ 2? YES → "1", 남은 값: 1
   - 1 ≥ 1? YES → "1"
   - 결과: **0111** (4비트)

### 출력
```
0000100110100111
```

분해하면:
- 00001 (ADD + C)
- 0 (미사용)
- 011 (rD=3)
- 010 (rA=2)
- 0111 (C=7, 4비트 전체 사용)

## 핵심 포인트

- **map 자료구조**: 명령어를 빠르게 찾기 위한 key-value 저장
- **문자열 조작**: back(), pop_back()으로 'C' 처리
- **십진수 → 이진수 변환**: 2의 거듭제곱으로 분해 (8, 4, 2, 1)
- **비트 수 맞추기**: 3비트는 정확히 3자리, 4비트는 정확히 4자리로 변환
- **중요! rB/C 처리**:
  - 'C'가 있으면 → 상수를 4비트로 (0~15)
  - 'C'가 없으면 → 레지스터를 3비트 + 0 (총 4비트, 0~7)
- **순서대로 조립**: opcode(5) + 0(1) + rD(3) + rA(3) + rB/C(4) = 16비트